#!/usr/bin/env ruby

# the file that stores the state
def state_file
  File.join ENV['DAITSS_WORKSPACE'], ".boss"
end

# read the state into an array of entries
def read_state
  
  open(state_file) do |io|
    io.readlines.map { |line| line.chomp.split }
  end
  
end

# write an arrary of entries as the state
def write_state state

  open(state_file, "w") do |io|
    state.each { |aip, pid| io.puts "#{aip} #{pid}" }
  end
  
end

# append an entry to the state
def append_state aip, pid
  open(state_file, "a") { |io| io.puts "#{aip} #{pid}" }
end

# start all packages in the workspace
command = ARGV.shift

case command
when "start"
  
  config_file = File.join File.dirname(__FILE__), '../spec/config/teststack.yml'
  
  aips = if ARGV.empty?
           Dir[File.join(ENV['DAITSS_WORKSPACE'], "*")] 
         else
            ARGV.map { |aip| File.join ENV['DAITSS_WORKSPACE'], aip }
         end

  aips.each do |aip|
    pid = fork { exec "ruby -Ilib bin/ingest -aip #{aip} -config #{config_file}" }
    append_state aip, pid
  end
  
when "stop"

  kill_predicate = if ARGV.empty?
    lambda { true }
  else
    lambda { |aip, md| ARGV.include? aip }
  end

  to_kill, to_keep = read_state.partition &kill_predicate

  to_kill.each do |aip, pid|
    
    begin
      Process.kill "INT", pid.to_i
    rescue Errno::ESRCH
      # OK if its done
    end
    
  end

  write_state to_keep
    
when "list"
  exec "cat #{state_file}"
  
else
  puts "#{command} is not a boss command"
  exit 1
end
